from flask import Flask
from threading import Thread
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import os
import json
from google.oauth2 import service_account
from googleapiclient.discovery import build

# ------------------- Telegram -------------------
TOKEN = os.getenv("BOT_TOKEN")

# ------------------- Google Drive -------------------
google_credentials = os.getenv("GOOGLE_CREDENTIALS")
if not google_credentials:
    raise ValueError("–ù–µ—Ç GOOGLE_CREDENTIALS! –î–æ–±–∞–≤—å –∫–ª—é—á –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Render.")

service_account_info = json.loads(google_credentials)

# üîë —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫ –≤ private_key
if "private_key" in service_account_info:
    service_account_info["private_key"] = service_account_info["private_key"].replace("\\n", "\n")

SCOPES = ['https://www.googleapis.com/auth/drive']
FOLDER_ID = '1nQECNPbttj32SnAhpdBjwWuYWJUUxtto'  # ID –ø–∞–ø–∫–∏ Obsidian –≤ Google Drive

credentials = service_account.Credentials.from_service_account_info(
    service_account_info, scopes=SCOPES
)
service = build('drive', 'v3', credentials=credentials)

# ------------------- Flask-—Å–µ—Ä–≤–µ—Ä -------------------
app_server = Flask(__name__)

@app_server.route("/")
def home():
    return "Bot is running!"

def run_server():
    app_server.run(host="0.0.0.0", port=int(os.environ.get("PORT", 10000)))

# ------------------- Telegram-–±–æ—Ç -------------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –Ø —Ä–∞–±–æ—Ç–∞—é –Ω–∞ Render ü§ñ\n\n"
                                    "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                                    "/list ‚Äî —Å–ø–∏—Å–æ–∫ –∑–∞–º–µ—Ç–æ–∫\n"
                                    "/note <–∏–º—è> ‚Äî –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–º–µ—Ç–∫—É")

async def echo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(update.message.text)

async def list_notes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    results = service.files().list(
        q=f"'{FOLDER_ID}' in parents and mimeType='text/markdown'",
        fields="files(id, name)"
    ).execute()
    files = results.get('files', [])
    if not files:
        await update.message.reply_text("–ó–∞–º–µ—Ç–æ–∫ –Ω–µ—Ç üò¢")
    else:
        names = "\n".join(file['name'] for file in files)
        await update.message.reply_text(f"–ó–∞–º–µ—Ç–∫–∏:\n{names}")

# üî• –Ω–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞
async def get_note(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /note <–∏–º—è_—Ñ–∞–π–ª–∞.md>")
        return

    filename = " ".join(context.args)

    # –∏—â–µ–º —Ñ–∞–π–ª –≤ –ø–∞–ø–∫–µ Obsidian
    results = service.files().list(
        q=f"'{FOLDER_ID}' in parents and name='{filename}'",
        fields="files(id, name)"
    ).execute()
    files = results.get('files', [])

    if not files:
        await update.message.reply_text("–¢–∞–∫–æ–π –∑–∞–º–µ—Ç–∫–∏ –Ω–µ—Ç üò¢")
        return

    file_id = files[0]['id']
    # —Å–∫–∞—á–∏–≤–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
    content = service.files().get_media(fileId=file_id).execute()
    text = content.decode("utf-8")

    # Telegram –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ 4096 —Å–∏–º–≤–æ–ª–∞–º–∏
    if len(text) > 4000:
        await update.message.reply_text(f"üìÑ {filename} (–ø–æ–∫–∞–∑–∞–Ω—ã –ø–µ—Ä–≤—ã–µ 4000 —Å–∏–º–≤–æ–ª–æ–≤):\n\n{text[:4000]}")
    else:
        await update.message.reply_text(f"üìÑ {filename}:\n\n{text}")


# ------------------- main -------------------

def main():
    if not TOKEN:
        raise ValueError("–ù–µ—Ç BOT_TOKEN! –î–æ–±–∞–≤—å –µ–≥–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Render.")
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º Flask-—Å–µ—Ä–≤–µ—Ä –≤ —Ñ–æ–Ω–µ –¥–ª—è Render
    thread = Thread(target=run_server)
    thread.start()

    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –±–æ—Ç–∞
    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("list", list_notes))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, echo))
    app.add_handler(CommandHandler("note", get_note))
    app.run_polling()
    

if __name__ == "__main__":
    main()
